<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üöÄ AI Implementation Test & Fix</title>
    <style>
        body { font-family: system-ui, sans-serif; padding: 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; }
        .container { max-width: 1400px; margin: 0 auto; }
        .card { background: rgba(255,255,255,0.1); border-radius: 16px; padding: 25px; margin: 20px 0; backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.2); }
        .button { background: #10b981; color: white; border: none; padding: 14px 28px; border-radius: 10px; cursor: pointer; font-size: 15px; margin: 8px; font-weight: 600; transition: all 0.3s; }
        .button:hover { background: #059669; transform: translateY(-2px); }
        .button:disabled { background: #6b7280; cursor: not-allowed; transform: none; }
        .button.critical { background: #ef4444; }
        .button.critical:hover { background: #dc2626; }
        .success { color: #34d399; font-weight: bold; }
        .error { color: #f87171; font-weight: bold; }
        .warning { color: #fbbf24; font-weight: bold; }
        .pre { background: rgba(0,0,0,0.3); padding: 20px; border-radius: 12px; font-family: 'Monaco', monospace; font-size: 13px; overflow-x: auto; border: 1px solid rgba(255,255,255,0.1); }
        .status { padding: 10px 16px; border-radius: 8px; font-weight: 600; display: inline-block; margin: 8px 0; }
        .status.success { background: rgba(16, 185, 129, 0.2); color: #34d399; border: 1px solid #10b981; }
        .status.error { background: rgba(239, 68, 68, 0.2); color: #f87171; border: 1px solid #ef4444; }
        .status.warning { background: rgba(251, 191, 36, 0.2); color: #fbbf24; border: 1px solid #f59e0b; }
        .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 25px; }
        .grid3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 20px; }
        .progress { background: rgba(255,255,255,0.1); border-radius: 10px; padding: 15px; margin: 10px 0; }
        .step { padding: 12px; margin: 8px 0; border-left: 4px solid #10b981; background: rgba(255,255,255,0.05); border-radius: 6px; }
        @media (max-width: 1024px) { .grid, .grid3 { grid-template-columns: 1fr; } }
        h1 { text-align: center; font-size: 2.5em; margin-bottom: 30px; }
        h2 { color: #fbbf24; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üöÄ AI Implementation Test & Fix</h1>
        <div class="card">
            <div class="progress">
                <h3>üìã Test Plan:</h3>
                <div class="step">1. API Verbindungen testen (OpenAI & Gemini)</div>
                <div class="step">2. Einzelne Testfragen generieren</div>
                <div class="step">3. 100 Fragen Batch-Generierung</div>
                <div class="step">4. Qualit√§tskontrolle & Datenbankstatus</div>
                <div class="step">5. End-to-End Funktionalit√§t best√§tigen</div>
            </div>
        </div>

        <div class="grid">
            <!-- Step 1: API Connection Test -->
            <div class="card">
                <h2>üîó Step 1: API Verbindungstest</h2>
                <button class="button" onclick="step1_testAPIs()">APIs testen</button>
                <div id="step1Results"></div>
            </div>

            <!-- Step 2: Single Question Test -->
            <div class="card">
                <h2>üìù Step 2: Einzelfragen Test</h2>
                <button class="button" onclick="step2_singleQuestions()">Testfragen generieren</button>
                <div id="step2Results"></div>
            </div>
        </div>

        <div class="grid">
            <!-- Step 3: Batch Generation -->
            <div class="card">
                <h2>üéØ Step 3: 100 Fragen Batch</h2>
                <button class="button critical" onclick="step3_generateBatch100()">üöÄ 100 Fragen generieren</button>
                <div id="step3Results"></div>
            </div>

            <!-- Step 4: Quality & DB Check -->
            <div class="card">
                <h2>üìä Step 4: Qualit√§tspr√ºfung</h2>
                <button class="button" onclick="step4_qualityCheck()">Qualit√§t & DB pr√ºfen</button>
                <div id="step4Results"></div>
            </div>
        </div>

        <!-- Step 5: End-to-End Test -->
        <div class="card">
            <h2>‚úÖ Step 5: End-to-End Test</h2>
            <button class="button" onclick="step5_endToEnd()">Vollst√§ndiger Test</button>
            <button class="button critical" onclick="runAllSteps()">üéØ ALLE SCHRITTE AUSF√úHREN</button>
            <div id="step5Results"></div>
        </div>

        <!-- Results Summary -->
        <div class="card">
            <h2>üìà Test Ergebnisse</h2>
            <div id="summaryResults"></div>
        </div>
    </div>

    <script>
        const SUPABASE_URL = 'https://fsmgynpdfxkaiiuguqyr.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZzbWd5bnBkZnhrYWlpdWd1cXlyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTI2OTg4ODYsImV4cCI6MjA2ODI3NDg4Nn0.unk2ST0Wcsw7RJz-BGrCqQpXSgLJQpAQPgJ-ImGCv-Q';

        let testResults = {};

        function logResult(containerId, message, data = null, type = 'info') {
            const container = document.getElementById(containerId);
            const timestamp = new Date().toLocaleTimeString();
            const statusClass = type === 'success' ? 'success' : type === 'error' ? 'error' : 'warning';
            
            const html = `
                <div class="status ${statusClass}">${timestamp} - ${message}</div>
                ${data ? `<div class="pre">${JSON.stringify(data, null, 2)}</div>` : ''}
            `;
            container.innerHTML += html;
            container.scrollTop = container.scrollHeight;
        }

        async function step1_testAPIs() {
            logResult('step1Results', 'üîç Teste API Verbindungen...', null, 'info');
            
            try {
                const response = await fetch(`${SUPABASE_URL}/functions/v1/test-openai-connection`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Content-Type': 'application/json'
                    }
                });

                const data = await response.json();
                testResults.apiTest = data;
                
                if (response.ok) {
                    const openAIWorking = data.openAI?.success;
                    const geminiWorking = data.gemini?.success;
                    
                    logResult('step1Results', '‚úÖ API Test durchgef√ºhrt', {
                        openAI: openAIWorking ? 'FUNKTIONIERT' : 'FEHLER',
                        gemini: geminiWorking ? 'FUNKTIONIERT' : 'FEHLER'
                    }, openAIWorking || geminiWorking ? 'success' : 'error');
                    
                    if (!openAIWorking && !geminiWorking) {
                        logResult('step1Results', '‚ùå KRITISCH: Beide APIs fehlerhaft!', data, 'error');
                    }
                } else {
                    logResult('step1Results', '‚ùå API Test fehlgeschlagen', data, 'error');
                    testResults.apiTest = { error: data };
                }
            } catch (error) {
                logResult('step1Results', '‚ùå API Test Fehler', { error: error.message }, 'error');
                testResults.apiTest = { error: error.message };
            }
        }

        async function step2_singleQuestions() {
            logResult('step2Results', 'üìù Teste Einzelfragen-Generierung...', null, 'info');
            
            // Test OpenAI
            try {
                const openaiResponse = await fetch(`${SUPABASE_URL}/functions/v1/generate-questions`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        grade: 2,
                        quarter: 'Q1',
                        domain: 'Zahlen & Operationen',
                        count: 1
                    })
                });

                const openaiData = await openaiResponse.json();
                testResults.openaiSingle = openaiData;
                
                if (openaiResponse.ok && openaiData.success) {
                    logResult('step2Results', '‚úÖ OpenAI Einzelfrage erfolgreich', openaiData, 'success');
                } else {
                    logResult('step2Results', '‚ùå OpenAI Einzelfrage fehlgeschlagen', openaiData, 'error');
                }
            } catch (error) {
                logResult('step2Results', '‚ùå OpenAI Einzelfrage Fehler', { error: error.message }, 'error');
                testResults.openaiSingle = { error: error.message };
            }

            await new Promise(resolve => setTimeout(resolve, 2000));

            // Test Gemini via batch generator
            try {
                const geminiResponse = await fetch(`${SUPABASE_URL}/functions/v1/batch-question-generator`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        totalQuestions: 1,
                        provider: 'gemini'
                    })
                });

                const geminiData = await geminiResponse.json();
                testResults.geminiSingle = geminiData;
                
                if (geminiResponse.ok && geminiData.success) {
                    logResult('step2Results', '‚úÖ Gemini Einzelfrage erfolgreich', geminiData.summary, 'success');
                } else {
                    logResult('step2Results', '‚ùå Gemini Einzelfrage fehlgeschlagen', geminiData, 'error');
                }
            } catch (error) {
                logResult('step2Results', '‚ùå Gemini Einzelfrage Fehler', { error: error.message }, 'error');
                testResults.geminiSingle = { error: error.message };
            }
        }

        async function step3_generateBatch100() {
            logResult('step3Results', 'üöÄ Starte 100 Fragen Batch-Generierung...', null, 'info');
            
            try {
                const response = await fetch(`${SUPABASE_URL}/functions/v1/batch-question-generator`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        totalQuestions: 100,
                        provider: 'mixed'
                    })
                });

                const data = await response.json();
                testResults.batch100 = data;
                
                if (response.ok && data.success) {
                    logResult('step3Results', 'üéâ 100 Fragen Batch ERFOLGREICH!', {
                        requested: data.summary?.requested,
                        generated: data.summary?.totalGenerated,
                        inserted: data.summary?.totalInserted,
                        successRate: Math.round((data.summary?.successRate || 0) * 100) + '%',
                        qualityScore: data.qualityReport?.avgQualityScore || 'N/A'
                    }, 'success');
                    
                    if (data.summary?.totalInserted >= 80) {
                        logResult('step3Results', '‚úÖ EXCELLENT: √úber 80% erfolgreich eingef√ºgt!', null, 'success');
                    } else if (data.summary?.totalInserted >= 50) {
                        logResult('step3Results', '‚ö†Ô∏è OK: 50-80% erfolgreich eingef√ºgt', null, 'warning');
                    } else {
                        logResult('step3Results', '‚ùå PROBLEM: Weniger als 50% eingef√ºgt', null, 'error');
                    }
                } else {
                    logResult('step3Results', '‚ùå 100 Fragen Batch FEHLGESCHLAGEN', data, 'error');
                }
            } catch (error) {
                logResult('step3Results', '‚ùå 100 Fragen Batch Fehler', { error: error.message }, 'error');
                testResults.batch100 = { error: error.message };
            }
        }

        async function step4_qualityCheck() {
            logResult('step4Results', 'üìä Pr√ºfe Datenbank und Qualit√§t...', null, 'info');
            
            try {
                // Check database status
                const dbResponse = await fetch(`${SUPABASE_URL}/rest/v1/templates?select=status,created_at,grade,domain,quality_score&order=created_at.desc&limit=1000`, {
                    headers: {
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'apikey': SUPABASE_ANON_KEY
                    }
                });

                const templates = await dbResponse.json();
                
                const now = new Date();
                const oneHourAgo = new Date(now.getTime() - 60*60*1000);
                
                const stats = {
                    total: templates.length,
                    active: templates.filter(t => t.status === 'ACTIVE').length,
                    archived: templates.filter(t => t.status === 'ARCHIVED').length,
                    recentActive: templates.filter(t => t.status === 'ACTIVE' && new Date(t.created_at) > oneHourAgo).length,
                    avgQuality: templates
                        .filter(t => t.quality_score)
                        .reduce((sum, t) => sum + (t.quality_score || 0), 0) / 
                        templates.filter(t => t.quality_score).length || 0
                };

                testResults.qualityCheck = stats;
                
                logResult('step4Results', 'üìä Datenbank Status', stats, 'success');
                
                if (stats.recentActive >= 50) {
                    logResult('step4Results', 'üéâ ERFOLG: Viele neue aktive Templates!', { recentActive: stats.recentActive }, 'success');
                } else if (stats.active > 0) {
                    logResult('step4Results', '‚ö†Ô∏è Einige aktive Templates vorhanden', { active: stats.active }, 'warning');
                } else {
                    logResult('step4Results', '‚ùå PROBLEM: Keine aktiven Templates!', null, 'error');
                }
                
            } catch (error) {
                logResult('step4Results', '‚ùå Qualit√§tspr√ºfung Fehler', { error: error.message }, 'error');
                testResults.qualityCheck = { error: error.message };
            }
        }

        async function step5_endToEnd() {
            logResult('step5Results', 'üéØ End-to-End Funktionalit√§tstest...', null, 'info');
            
            // Generate final summary
            const summary = {
                apiWorking: testResults.apiTest?.openAI?.success || testResults.apiTest?.gemini?.success,
                singleQuestionsWork: testResults.openaiSingle?.success || testResults.geminiSingle?.success,
                batchGeneration: testResults.batch100?.success,
                activeTemplates: testResults.qualityCheck?.active > 0,
                newTemplatesCreated: testResults.qualityCheck?.recentActive > 0
            };
            
            const allWorking = Object.values(summary).every(Boolean);
            
            logResult('step5Results', 'üìã End-to-End Ergebnis:', summary, allWorking ? 'success' : 'error');
            
            if (allWorking) {
                logResult('step5Results', 'üéâ AI IMPLEMENTIERUNG ERFOLGREICH!', null, 'success');
                logResult('summaryResults', '‚úÖ ALLE TESTS BESTANDEN - KI-FUNKTIONALIT√ÑT VOLLST√ÑNDIG FUNKTIONSF√ÑHIG!', testResults, 'success');
            } else {
                logResult('step5Results', '‚ùå AI Implementierung hat noch Probleme', summary, 'error');
                logResult('summaryResults', '‚ö†Ô∏è Einige Tests fehlgeschlagen - weitere Korrekturen n√∂tig', testResults, 'warning');
            }
        }

        async function runAllSteps() {
            logResult('summaryResults', 'üöÄ Starte vollst√§ndigen AI-Implementierungstest...', null, 'info');
            
            await step1_testAPIs();
            await new Promise(resolve => setTimeout(resolve, 2000));
            
            await step2_singleQuestions();
            await new Promise(resolve => setTimeout(resolve, 2000));
            
            await step3_generateBatch100();
            await new Promise(resolve => setTimeout(resolve, 3000));
            
            await step4_qualityCheck();
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            await step5_endToEnd();
        }
    </script>
</body>
</html>
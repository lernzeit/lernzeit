import "https://deno.land/x/xhr@0.1.0/mod.ts";
import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.51.0';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

// Initialize Supabase client with service role key for admin operations
const supabaseUrl = Deno.env.get('SUPABASE_URL')!;
const supabaseServiceRoleKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!;
const supabase = createClient(supabaseUrl, supabaseServiceRoleKey);

// LLM Configuration
const geminiApiKey = Deno.env.get('GEMINI_API_KEY');
const openaiApiKey = Deno.env.get('OPENAI_API_KEY');

interface KnowledgeCard {
  id: string;
  grade: number;
  grade_app: number;
  quarter_app: string;
  domain: string;
  subcategory: string;
  skill: string;
  tags: string[];
  text: string;
}

interface Blueprint {
  id: string;
  domain: string;
  subcategory: string;
  question_type: string;
  grade_suggestion: number;
  quarter_app: string;
  tags: string[];
  validation: string;
  template: string;
  structure: string;
  contexts: string[];
}

interface GeneratedTemplate {
  grade_suggestion: number;
  quarter_app: string;
  subcategory: string;
  difficulty: string;
  question_type: string;
  student_prompt: string;
  variables: Record<string, any>;
  solution: string;
  unit?: string;
  distractors: string[];
  explanation_teacher: string;
  source_skill_id: string;
  tags: string[];
  seed: string;
}

async function loadKnowledgeCards(): Promise<KnowledgeCard[]> {
  try {
    // Try to load from public URL first
    const response = await fetch(`${supabaseUrl}/storage/v1/object/public/knowledge/knowledge_cards.jsonl`);
    if (response.ok) {
      const text = await response.text();
      return text.split('\n').filter(line => line.trim()).map(line => JSON.parse(line));
    }
  } catch (error) {
    console.log('Failed to load from storage, using fallback:', error);
  }

  // Fallback: Load from direct URL
  try {
    const response = await fetch('https://raw.githubusercontent.com/your-repo/main/public/data/knowledge_cards.jsonl');
    if (response.ok) {
      const text = await response.text();
      return text.split('\n').filter(line => line.trim()).map(line => JSON.parse(line));
    }
  } catch (error) {
    console.error('Failed to load knowledge cards:', error);
  }

  return [];
}

async function loadBlueprints(): Promise<Blueprint[]> {
  try {
    // Try to load from public URL first
    const response = await fetch(`${supabaseUrl}/storage/v1/object/public/knowledge/item_blueprints_extended.json`);
    if (response.ok) {
      return await response.json();
    }
  } catch (error) {
    console.log('Failed to load from storage, using fallback:', error);
  }

  // Fallback: Load from direct URL
  try {
    const response = await fetch('https://raw.githubusercontent.com/your-repo/main/public/item_blueprints_extended.json');
    if (response.ok) {
      return await response.json();
    }
  } catch (error) {
    console.error('Failed to load blueprints:', error);
  }

  return [];
}

function filterKnowledgeCards(
  knowledgeCards: KnowledgeCard[], 
  grade: number, 
  domain?: string
): KnowledgeCard[] {
  return knowledgeCards.filter(card => {
    // Filter by grade (grade_app <= target grade)
    if (card.grade_app > grade) return false;
    
    // Filter by domain if specified
    if (domain && card.domain !== domain) return false;
    
    return true;
  });
}

function filterBlueprints(
  blueprints: Blueprint[], 
  domain: string, 
  grade: number
): Blueprint[] {
  return blueprints.filter(blueprint => {
    // Domain match
    if (blueprint.domain !== domain) return false;
    
    // Grade appropriateness (within ¬±2 grades)
    if (Math.abs(blueprint.grade_suggestion - grade) > 2) return false;
    
    return true;
  });
}

async function generateWithGemini(prompt: string): Promise<any> {
  if (!geminiApiKey) {
    throw new Error('GEMINI_API_KEY not configured');
  }

  const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${geminiApiKey}`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      contents: [{
        parts: [{
          text: prompt
        }]
      }],
      generationConfig: {
        temperature: 0.7,
        maxOutputTokens: 2048,
      }
    }),
  });

  if (!response.ok) {
    throw new Error(`Gemini API error: ${response.status}`);
  }

  const data = await response.json();
  const content = data.candidates?.[0]?.content?.parts?.[0]?.text;
  
  if (!content) {
    throw new Error('No content generated by Gemini');
  }

  return JSON.parse(content);
}

function buildPrompt(
  knowledgeCards: KnowledgeCard[], 
  blueprint: Blueprint, 
  difficulty: string, 
  count: number
): string {
  const knowledgeContext = knowledgeCards.slice(0, 8).map(card => 
    `- ${card.domain}: ${card.skill} (${card.subcategory})`
  ).join('\n');

  const contexts = blueprint.contexts?.join(', ') || 'Alltag, Schule';
  
  return `Erstellen Sie ${count} deutsche Mathematikaufgaben basierend auf:

**Blueprint:**
- Domain: ${blueprint.domain}
- Template: ${blueprint.template}
- Struktur: ${blueprint.structure}
- Kontexte: ${contexts}

**Schwierigkeitsgrad:** ${difficulty}

**Relevantes Wissen:**
${knowledgeContext}

**Anforderungen:**
- Schwierigkeitsverteilung: AFB I (50%), AFB II (35%), AFB III (15%)
- Itemtyp-Mix: Multiple Choice (45%), Text-Input (35%), Matching (20%)
- Realistische Kontexte: Einkaufen, Sport, Natur, Schule, Alltag
- Deutsche Sprache, altersgerecht formuliert
- Vielf√§ltige Zahlenwerte (auch "krumme" Zahlen)
- WICHTIG: Verwende Platzhalter {variable} f√ºr parametrisierbare Werte
- KRITISCH: Keine visuellen/Zeichenaufgaben! Vermeide: zeichne, male, konstruiere, entwirf, Bilder, Ordne...zu, Verbinde, Netze, K√∂rper, Diagramme, Graphen

**JSON-Ausgabe (Array):**
[{
  "grade_suggestion": number,
  "quarter_app": "Q1|Q2|Q3|Q4", 
  "subcategory": string,
  "difficulty": "AFB I|AFB II|AFB III",
  "question_type": "multiple-choice|text-input|matching",
  "student_prompt": string (mit {Platzhaltern} f√ºr Parameter),
  "variables": {},
  "solution": string (kann {Platzhalter} enthalten),
  "unit": string?,
  "distractors": string[] (f√ºr MC: 3 falsche Antworten, k√∂nnen {Platzhalter} enthalten),
  "explanation_teacher": string,
  "source_skill_id": string,
  "tags": string[],
  "seed": string (unique identifier)
}]

Bitte ${count} verschiedene, hochwertige Aufgaben erstellen!`;
}

function validateTemplate(template: GeneratedTemplate): { valid: boolean; errors: string[] } {
  const errors: string[] = [];

  // Required fields
  if (!template.student_prompt?.trim()) errors.push('student_prompt fehlt');
  if (!template.solution?.trim()) errors.push('solution fehlt');  
  if (!template.difficulty) errors.push('difficulty fehlt');
  if (!template.question_type) errors.push('question_type fehlt');

  // Field validation
  if (!['AFB I', 'AFB II', 'AFB III'].includes(template.difficulty)) {
    errors.push('difficulty muss AFB I, II oder III sein');
  }
  
  if (!['multiple-choice', 'text-input', 'matching', 'drag-drop'].includes(template.question_type)) {
    errors.push('Ung√ºltiger question_type');
  }

  // Text length limits
  const maxPromptLength = template.grade_suggestion <= 4 ? 240 : 350;
  if (template.student_prompt.length > maxPromptLength) {
    errors.push(`student_prompt zu lang (${template.student_prompt.length}/${maxPromptLength})`);
  }

  // Multiple choice validation
  if (template.question_type === 'multiple-choice') {
    if (!Array.isArray(template.distractors) || template.distractors.length !== 3) {
      errors.push('Multiple Choice braucht genau 3 Distraktoren');
    }
  }

  // Filter out drawing instructions and visual questions
  const drawingKeywords = [
    'zeichne', 'zeichnet', 'zeichnen', 'male', 'malt', 'malen', 
    'skizziere', 'konstruiere', 'entwirf', 'entwerfen', 'entwirft',
    'bild', 'bilder', 'abbildung', 'ordne', 'ordnet', 'ordnen', 'zuordnen',
    'verbind', 'verbindet', 'verbinden', 'netz', 'netze', 'k√∂rper',
    'diagramm', 'graph', 'graphen', 'tabelle passt', 'welches bild'
  ];
  const lowerPrompt = template.student_prompt.toLowerCase();
  if (drawingKeywords.some(keyword => lowerPrompt.includes(keyword))) {
    errors.push('Visuelle/Zeichen-Aufgaben sind in der aktuellen UI nicht umsetzbar');
  }

  return { valid: errors.length === 0, errors };
}

function generateTemplateHash(template: GeneratedTemplate, blueprintId: string): string {
  const hashInput = `${blueprintId}-${template.question_type}-${template.student_prompt}-${JSON.stringify(template.variables)}`;
  
  // Simple hash function (in production, use crypto.subtle.digest)
  let hash = 0;
  for (let i = 0; i < hashInput.length; i++) {
    const char = hashInput.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash; // Convert to 32-bit integer
  }
  
  return Math.abs(hash).toString(16);
}

async function checkDuplicates(templates: GeneratedTemplate[], blueprintId: string): Promise<GeneratedTemplate[]> {
  const uniqueTemplates: GeneratedTemplate[] = [];
  const seenHashes = new Set<string>();

  for (const template of templates) {
    const hash = generateTemplateHash(template, blueprintId);
    
    // Check if hash already exists in database
    const { data: existing } = await supabase
      .from('templates')
      .select('id')
      .eq('source_skill_id', template.source_skill_id)
      .eq('student_prompt', template.student_prompt)
      .limit(1);

    if (existing && existing.length > 0) {
      console.log(`Duplicate found, skipping: ${template.student_prompt}`);
      continue;
    }

    if (!seenHashes.has(hash)) {
      seenHashes.add(hash);
      uniqueTemplates.push(template);
    }
  }

  return uniqueTemplates;
}

function generateParameterDefinitions(template: GeneratedTemplate): Record<string, any> {
  const paramDefs: Record<string, any> = {};
  
  // Extrahiere Parameter aus student_prompt ({variable} Format)
  const paramMatches = template.student_prompt.match(/\{(\w+)\}/g);
  if (paramMatches) {
    paramMatches.forEach(match => {
      const paramName = match.slice(1, -1); // Entferne { und }
      
      // Intelligente Parameter-Definition basierend auf Name
      if (paramName.includes('zahl') || paramName.includes('number')) {
        paramDefs[paramName] = {
          type: 'number',
          curriculum_rule: 'zahlenraum_grade_quarter'
        };
      } else if (paramName.includes('name')) {
        paramDefs[paramName] = {
          type: 'word',
          curriculum_rule: 'age_appropriate_names'
        };
      } else if (paramName.includes('gegenstand') || paramName.includes('object')) {
        paramDefs[paramName] = {
          type: 'word',
          curriculum_rule: 'context_objects'
        };
      } else {
        // Standard-Definition
        paramDefs[paramName] = {
          type: 'text',
          curriculum_rule: 'default'
        };
      }
    });
  }
  
  return paramDefs;
}

function generateCurriculumRules(grade: number, quarter: string, domain: string): Record<string, any> {
  const baseRules = {
    zahlenraum_grade_quarter: {
      grade,
      quarter,
      domain
    },
    age_appropriate_names: {
      grade_level: grade <= 4 ? 'elementary' : 'secondary'
    },
    context_objects: {
      contexts: grade <= 4 ? ['toys', 'animals', 'food'] : ['technology', 'sports', 'science']
    }
  };
  
  // Domain-spezifische Regeln
  if (domain === 'Zahlen & Operationen') {
    const zahlenraum = getZahlenraumForGrade(grade);
    baseRules.zahlenraum_grade_quarter = {
      ...baseRules.zahlenraum_grade_quarter,
      min_value: zahlenraum.min,
      max_value: zahlenraum.max
    };
  }
  
  return baseRules;
}

function getZahlenraumForGrade(grade: number): { min: number; max: number } {
  const zahlenraeume: Record<number, { min: number; max: number }> = {
    1: { min: 1, max: 20 },
    2: { min: 1, max: 100 },
    3: { min: 1, max: 1000 },
    4: { min: 1, max: 10000 },
    5: { min: -100, max: 100000 },
    6: { min: -1000, max: 1000000 },
    7: { min: -1000, max: 1000000 },
    8: { min: -1000000, max: 1000000 },
    9: { min: -1000000, max: 1000000 },
    10: { min: -1000000, max: 1000000 }
  };
  
  return zahlenraeume[grade] || { min: 1, max: 100 };
}

async function insertTemplates(templates: GeneratedTemplate[], domain: string): Promise<void> {
  const dbTemplates = templates.map(template => {
    const hasPlaceholders = template.student_prompt.includes('{');
    const isParametrized = hasPlaceholders || Math.random() < 0.3; // 30% Basis-Chance + immer wenn Platzhalter vorhanden
    
    return {
      grade: template.grade_suggestion,
      grade_app: template.grade_suggestion,
      quarter_app: template.quarter_app,
      domain: domain,
      subcategory: template.subcategory,
      difficulty: template.difficulty,
      question_type: template.question_type,
      student_prompt: template.student_prompt,
      variables: template.variables || {},
      solution: template.solution,
      unit: template.unit,
      distractors: template.distractors || [],
      explanation_teacher: template.explanation_teacher,
      source_skill_id: template.source_skill_id,
      tags: template.tags || [],
      seed: template.seed ? parseInt(template.seed) : Math.floor(Math.random() * 1000000),
      status: 'ACTIVE',
      is_parametrized: isParametrized,
      parameter_definitions: isParametrized ? generateParameterDefinitions(template) : {},
      curriculum_rules: isParametrized ? generateCurriculumRules(template.grade_suggestion, template.quarter_app, domain) : {}
    };
  });

  const { error } = await supabase
    .from('templates')
    .insert(dbTemplates);

  if (error) {
    console.error('Error inserting templates:', error);
    throw error;
  }

  const parametrizedCount = dbTemplates.filter(t => t.is_parametrized).length;
  console.log(`‚úÖ Inserted ${dbTemplates.length} templates for domain: ${domain} (${parametrizedCount} parametrized)`);
}

async function seedTemplates(grade?: number, domain?: string, count: number = 12): Promise<any> {
  console.log(`üå± Starting template seeding - Grade: ${grade || 'all'}, Domain: ${domain || 'all'}, Count: ${count}`);
  
  // Load data
  const [knowledgeCards, blueprints] = await Promise.all([
    loadKnowledgeCards(),
    loadBlueprints()
  ]);

  console.log(`üìö Loaded ${knowledgeCards.length} knowledge cards, ${blueprints.length} blueprints`);

  const results = {
    total_generated: 0,
    total_inserted: 0,
    parametrized_inserted: 0,
    errors: [] as string[],
    domains_processed: [] as string[]
  };

  // Define target domains
  const targetDomains = domain ? [domain] : [
    'Zahlen & Operationen',
    'Gr√∂√üen & Messen', 
    'Raum & Form',
    'Gleichungen & Funktionen',
    'Daten & Zufall'
  ];

  // Define target grades  
  const targetGrades = grade ? [grade] : [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

  for (const targetDomain of targetDomains) {
    for (const targetGrade of targetGrades) {
      try {
        console.log(`\nüéØ Processing: Grade ${targetGrade}, Domain: ${targetDomain}`);

        // Filter knowledge cards and blueprints
        const relevantKnowledge = filterKnowledgeCards(knowledgeCards, targetGrade, targetDomain);
        const relevantBlueprints = filterBlueprints(blueprints, targetDomain, targetGrade);

        console.log(`üìã Found ${relevantKnowledge.length} knowledge cards, ${relevantBlueprints.length} blueprints`);

        if (relevantKnowledge.length === 0 || relevantBlueprints.length === 0) {
          console.log(`‚ö†Ô∏è Skipping - insufficient data`);
          continue;
        }

        // Generate templates for each blueprint
        for (const blueprint of relevantBlueprints.slice(0, 3)) { // Limit to 3 blueprints per domain/grade
          try {
            // Generate templates with different difficulties
            const difficulties = ['AFB I', 'AFB II', 'AFB III'];
            
            for (const difficulty of difficulties) {
              const templatesPerDifficulty = Math.ceil(count / difficulties.length);
              const prompt = buildPrompt(relevantKnowledge, blueprint, difficulty, templatesPerDifficulty);
              
              console.log(`ü§ñ Generating ${templatesPerDifficulty} templates with ${difficulty}`);
              
              const generated = await generateWithGemini(prompt);
              const templates = Array.isArray(generated) ? generated : [generated];
              
              // Validate templates
              const validTemplates: GeneratedTemplate[] = [];
              for (const template of templates) {
                const validation = validateTemplate(template);
                if (validation.valid) {
                  validTemplates.push(template);
                } else {
                  console.log(`‚ùå Invalid template: ${validation.errors.join(', ')}`);
                  results.errors.push(`Validation failed: ${validation.errors.join(', ')}`);
                }
              }

              if (validTemplates.length > 0) {
                // Remove duplicates
                const uniqueTemplates = await checkDuplicates(validTemplates, blueprint.id);
                
                if (uniqueTemplates.length > 0) {
                  // Insert into database
                  await insertTemplates(uniqueTemplates, targetDomain);
                  results.total_inserted += uniqueTemplates.length;
                  
                  // Count parametrized templates
                  const parametrizedCount = uniqueTemplates.filter(t => 
                    t.student_prompt.includes('{') || Math.random() < 0.3
                  ).length;
                  results.parametrized_inserted += parametrizedCount;
                }
              }

              results.total_generated += templates.length;
            }
          } catch (error) {
            console.error(`‚ùå Error processing blueprint ${blueprint.id}:`, error);
            results.errors.push(`Blueprint ${blueprint.id}: ${error.message}`);
          }
        }

        results.domains_processed.push(`${targetDomain}-${targetGrade}`);
        
      } catch (error) {
        console.error(`‚ùå Error processing grade ${targetGrade}, domain ${targetDomain}:`, error);
        results.errors.push(`Grade ${targetGrade}, Domain ${targetDomain}: ${error.message}`);
      }
    }
  }

  console.log(`\nüéâ Template seeding complete!`);
  console.log(`üìä Generated: ${results.total_generated}, Inserted: ${results.total_inserted}, Parametrized: ${results.parametrized_inserted}`);
  
  return results;
}

serve(async (req) => {
  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const url = new URL(req.url);
    const grade = url.searchParams.get('grade') ? parseInt(url.searchParams.get('grade')!) : undefined;
    const domain = url.searchParams.get('domain') || undefined;
    const count = url.searchParams.get('n') ? parseInt(url.searchParams.get('n')!) : 12;

    console.log(`üöÄ Seed templates request: grade=${grade}, domain=${domain}, count=${count}`);

    const result = await seedTemplates(grade, domain, count);

    return new Response(JSON.stringify({
      success: true,
      message: `Template seeding completed`,
      data: result
    }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });

  } catch (error) {
    console.error('‚ùå Error in seed_templates function:', error);
    return new Response(JSON.stringify({ 
      success: false,
      error: error.message 
    }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});
